# TODO
- 『初めてのGraphQL』を読む。
  - Express + MongoDBでのApollo実装は一旦飛ばす
  - 全部読んだあとにネットでGraphQLRubyのドキュメントを見て、いち早く実装できるようにする
  - その後興味あればExpressとMongoDBを学ぶ
- ↑の写経
- サンプルアプリを作る
- 本リポジトリの開発環境に活かす

# 結論始める時どんな手順を踏むか
- server側
  - [この記事](https://qiita.com/dkawabata/items/)のようにやって`rails generate graphql:install`とか打つ
  - [CORS](https://qiita.com/sugo/items/9c5f9cc5d88e6d7efa2d#rack-cors%E3%81%AE%E5%88%A9%E7%94%A8)の設定
- client側
  - 

# 『初めてのGraphQL』を読んで
- ApolloClient
  - 最悪curlで事足りる
  - 強力なツールを使いたい場合に使う
  - ApolloServer, ApolloClientともに思想を知りたいな→Apolloで有名なのはClientっぽい。Server側もあるかもだけど。
  
# サンプルで組んでみて
- GraphQLRuby、GraphQLRailsを入れてみる
  - ドキュメント
    - [github](https://github.com/rmosolgo/graphql-ruby)
    - [Qiita](https://qiita.com/dkawabata/items/4fd965ee6d7295386a8b)
  - 雑記
    - `rails generate graphql:install`で起動。以下のファイルができる
      - `app/graphql/~`
      - `app/controllers/graphql_controller.rb`
    - サンプルであるクエリ例が`testField`とキャメル
      - APIのURLならスネークにしたいけど、jsのコードの中に書くコードだからキャメルでいっか。無理にデフォルトを変えないで。
    - `app/graphql/types/query_type.rb`
      - ここで型とデータ返却処理を記述
      - 型はファイル分かれているけど、処理もここに書かなきゃいけないから、でっかいアプリケーションコントローラーみたいになりそう。
      - すぐにファイル分けんと気持ち悪い。処理は別ファイルにしてroutes.rbみたいな集約を行う分け方になりそう。やり方は諸説あるけど
        - `def user(id:) UserResolver.user end`みたいな移譲
        - `UserResolver`とか別ファイルにフィールド定義も書いて~~includeする~~[それ用の記法を使う](https://qiita.com/kshibata101/items/4fa24fea575c5e5e0ce1)
      - [ここ](https://blog.spacemarket.com/code/graphql-ruby-concerns/)でもタイプすらも分けるのやっててすぐやりそう。input型とかでディレクトリをわけるかビジネス的な塊で分けるかは別として。
- jsにapolloを入れて
  - 本の通りやって通信失敗。なぜかOPTIONSメソッドが使われていた
    - [公式ドキュメント](https://github.com/apollographql/apollo-client/blob/master/src/ApolloClient.ts)を見てみる
    - `Access to fetch at 'http://localhost:30426/graphql' from origin 'http://localhost:30425' has been`
    - [CORS](https://qiita.com/sugo/items/9c5f9cc5d88e6d7efa2d#rack-cors%E3%81%AE%E5%88%A9%E7%94%A8)の設定不足っていう基本的なこと
- sampleアプリの失敗。これは動くことだけ分かればいいや。実際に失敗メモとかはこのリポジトリのアプリに書きたいからやりすぎちゃいけない
  - sampleアプリでは起動だけしてdockerアプリに入れるか判断するくらい
  - dockerアプリではビジネスロジックの関係ない技術オンリーなことを試す
  - 実際のアプリでビジネスロジックと絡んだ技術実装を試す

# 自分のアプリに入れてみて
- reduxとapolloは共存できるのか。特にreduxの`Provider`とapploの`ApolloProvider`は共存できるのか
  - ApolloProviderにstoreを入れる余地がなかったことから
  - [ここ](https://qiita.com/pokotyan/items/e71b0f0bcc1903ce4f54#%E3%82%AF%E3%83%A9%E3%82%A4%E3%82%A2%E3%83%B3%E3%83%88%E5%81%B4%E3%81%AE%E5%AE%9F%E8%A3%85)にあるように入れ子にすれば大丈夫らしい
    - この記事によるとgrqphqlを使うとreduxが必要なくなるとのこと。ものすごく期待。正確に言うとApolloClientのキャッシュとQuery,Mutateコンポーネントでのライフサイクルがreduxの代わりをする
    - `apollo-link-state`とかもあって、オライリーの本以外にデファクトスタンダードがありそうだから、一通り実装して実アプリも1個機能改修したらちょっと調べてみよう
- Queryタグはどのタイミングで最新に変わるんだろう
  - ページ再描画では最新になると思うし、n秒ごとというのも設定できた
  - でもきになるのは変更加えた後に最新になるかと言う話
  - MutationタグのrefetchQueries
- オライリーでは`ROOT_QUERY`を元にしたGraphQLのクエリ集を引き回して`<Query>`タグを使っているけど、そんなことしたらトップダウンで管理しにくくなるんじゃないか？
  - [子コンポーネントで小さくクエリ使うことできそう](https://github.com/amberbit/commentable/blob/9de79bd90ba81719146390f52bb81ffeba327f11/apps/ui/assets/js/components/CommentableWidget.js)
  - Mutationでクエリを指定してrefetchできることと合わせると
    - 1つのトップを中心としたトップダウンでなくていいことはわかったが、グローバルに定義しまくるとそれはそれで管理しにくそう。
    - まぁ、グローバルに定義して変わるべきタイミングで適切に変わるのもそれはそれでよさそうだけど。
    - Mutationで変えるのはどこかのクエリタイプに定義されたものだから、Queryしているものと共通のものを使うということで、自由といえどもMutation側は参照識別子を使ってるっぽい感じだけど
  - どうしようか
    - 取りうる方法
      - A. QueryとMutationはお互い気にせず存在していい。
        - ただMutation側はQueryで使っているものを参照識別子的に使うことになる。
        - となるとQueryの扱いは`app/models`のようにデータの集合がたくさんある運用になるのか？
        - ただそうするとRESTと同じ過小のクエリが増えるからいやだ。
      - B. 関心のトップにQueryタグとGraphQLクエリを用意し、それらに関連することはその配下でのみいじる
        - AほどじゃないけどGraphQLのよさはあまり活かせないかもしれない。コンポーネントべったりなエンドポイント設計になるから。
          - まぁそうだとしてもapollo使うだけでreduxがかなりすっきりするし、コンポーネントべったりといえどもRESTやRPCだと1コンポーネントでも複数エンドポイント貼るからそれが減るだけでも嬉しい。
    - 上記の判断により組むべきディレクトリ構成が変わる。Githubのいろんなのを見てみたい
    - Aは問題含みっぽいからAのように関心のコンポーネントでディレクトリ作って、reduxのviewと~modelsがセットになっているのが使いやすいように、関心の中でviewとデータがMVCをサイクル仕組みが綺麗そうだな
    - modelsが`queries`と`mutations`になるイメージかな。なんかORMapperっぽい。QLだからかな
    - viewModelsはGraphQL化は難しそう。だけどredux使って中央管理するほどでもないからローカルステートでもいい気もする。
- ディレクトリ構成探訪
  - [tsxファイルのリポジトリ](https://github.com/search?l=TSX&p=2&q=import+Query+react-apollo&type=Code)を見てみたらちゃんと作った人が多そうで、サンプルアプリリポジトリをかなり足切りできていい
  - [これ](https://github.com/jharrilim/downtime/tree/7640906ab1d0b9d7e5d1d778af5f8d3d73825fa0/client/src)のようにcompornentとデータをトップレベルで分けているリポジトリを結構見かける
  - 正しいかどうかは知らないけど、[関心ごとに分けているリポジトリ](https://github.com/storyvine/storyvine-web-app/blob/bbcc5d55267f05bdfa31122a0a04f1e4e9484e03/app/modules/VariablesDashboard/VariablesDashboard.tsx)も存在する
    - これは色々勉強になる。
      - renderメソッド前にtsxをめっちゃ定義してrenderはmainメソッドに徹しているところ
      - Mutationタグのupdate属性
  
## 本に書いてなくて自分でリファレンスやチュートリアルを見て学んだこと
- [引数の設定の仕方](https://graphql-ruby.org/getting_started)
  - GraphQLRuby
    - `QueryType`でfieldメソッド内の[argumentに入れたい引数の型を入れる](https://graphql-ruby.org/getting_started#build-a-schema)
      - `GraphQL::Schema::Field`の[initializeの引数に設定されているもの](https://github.com/rmosolgo/graphql-ruby/blob/1a9a20f3da629e63ea8e5ee8400be82218f9edc3/lib/graphql/schema/field.rb#L196)
      - なぜそこを見たか：`QueryType < Types::BaseObject`という表記から追って`Types::BaseObject`が使っているクラスが[GraphQL::Schema::Field](https://github.com/rmosolgo/graphql-ruby/blob/0cc55ae620db74af98a978b5b0623ee800dff266/lib/graphql/schema/member/has_fields.rb#L11)が使っていたため
    - 引数の設定方法
      - [設定例](https://graphql-ruby.org/fields/arguments.html)
      - [設定できる値](https://graphql-ruby.org/api-doc/1.10.8/GraphQL/Schema/Argument.html)
      - 複数の引数を設定する場合はattr_readerとかみたいにまたargument記法を書く。ドキュメントはなかったからえいやでやったら複数設定できたから、とりあえずそれで対応
    - [GraphQL::Schema::Resolver](https://github.com/rmosolgo/graphql-ruby/blob/master/lib/graphql/schema/resolver.rb#L226)には型とnull制約しか入らない
  - ApolloClientのQueryタグ
    - variablesフィールドに入れればよさそう([参考](https://github.com/apollographql/react-apollo/blob/master/packages/components/src/Query.tsx#L15))
- 気づいたらフォーム作成の必要性に迫られていた
  - これがredux-formが使いにくくても使った理由だけど、触り始めたら触るたびに必要なものが増えて面倒くさいパティーン。
  - ただ、簡単に調べてみる限りapolloのいい感じのformライブラリはないらしい
  - ただただformタグ内のinputタグのname属性と値をとるだけで、apolloを使うだけでかなり簡略化されてるからみんな自前でやれちゃう範囲なのかも。
  - formicってやつ使ってみよっかな。redux使わないからreduxFormもやりたくないし。
    - ドキュメント
      - [なんかいい実装](https://stackoverflow.com/questions/52916733/apollo-form-state-management)
      - [formicとapolloのqiita](https://qiita.com/pokotyan/items/b47c55563461982366a9#%E3%83%95%E3%82%A9%E3%83%BC%E3%83%A0%E3%81%8C%E4%BD%9C%E3%82%8A%E3%81%9F%E3%81%84)
      - [formicのqiita](https://qiita.com/akameco/items/0151c7c15b7967a147ec)
      - [formicのドキュメント](https://jaredpalmer.com/formik/docs/overview)
    - 小並感だけどformikよかった。シンプルだから使いやすい
    - formikのI/F
      - 使われ方 `<Formic ...InputParams, onSubmit=(SubmitParams) => submit処理> {(...OutputParams) => formのjsx} </Formic>`
      - [InputParams](https://jaredpalmer.com/formik/docs/api/formik)
        - [Github](https://github.com/jaredpalmer/formik/blob/master/packages/formik/src/Formik.tsx#L133) 
      - [OutputParams](https://github.com/jaredpalmer/formik/blob/master/packages/formik/src/Formik.tsx#L959)
        - initialValues: initialValues.current
        - initialErrors: initialErrors.current
        - initialTouched: initialTouched.current
        - initialStatus: initialStatus.current
        - handleBlur
        - handleChange
        - handleReset
        - handleSubmit
        - resetForm
        - setErrors
        - setFormikState
        - setFieldTouched
        - setFieldValue
        - setFieldError
        - setStatus
        - setSubmitting
        - setTouched
        - setValues
        - submitForm
        - validateForm: validateFormWithHighPriority
        - validateField
        - isValid
        - dirty
        - unregisterField
        - registerField
        - getFieldProps
        - getFieldMeta
        - getFieldHelpers
        - validateOnBlur
        - validateOnChange
        - validateOnMount
      - [SubmitParams](https://github.com/jaredpalmer/formik/blob/master/packages/formik/src/Formik.tsx#L842)
        - resetForm
        - validateForm: validateFormWithHighPriority
        - validateField
        - setErrors
        - setFieldError
        - setFieldTouched
        - setFieldValue
        - setStatus
        - setSubmitting
        - setTouched
        - setValues
        - setFormikState
        - submitForm
    - formとapolloの連携
      - MutationタグとFormikタグの相互循環。
        - Mutationタグ作るときのvariablesはFormikでつくる
        - react-apolloのgraphqlを使うとvariablesとかを処理実行時に入れられるので依存関係を逆転できる
          - 結局中でやっていることは[Mutationタグ](https://github.com/apollographql/react-apollo/blob/master/packages/hoc/src/mutation-hoc.tsx#L69)
          - でもloadingとかerrorとか使えなくなる
      - 入れ子が多くなったときには`compose`メソッドですっきりする
        - [qiita](https://qiita.com/pokotyan/items/b47c55563461982366a9#%E3%83%95%E3%82%A9%E3%83%BC%E3%83%A0%E3%81%8C%E4%BD%9C%E3%82%8A%E3%81%9F%E3%81%84)
        - [コード例](https://gist.github.com/tb/4a3a6d19c82a66ee04e1cb6564649e35)
      - [withFormik](https://jaredpalmer.com/formik/docs/api/withFormik#__docusaurus)
        - でもwithFormikをうまく使えない気がするから、[これ](https://gist.github.com/tb/4a3a6d19c82a66ee04e1cb6564649e35#file-formikapollo-js-L81)チックなことする
        - 